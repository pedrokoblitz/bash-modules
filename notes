is function?
if [ -n "$(type -t rvm)" ] && [ "$(type -t rvm)" = function ]; then echo rvm is a function; else echo rvm is NOT a function; fi
rvm is a function


set -o nounset # exit if any var is not set
set -e # exit if any line returns not true


# while [ "$name" != Smith ]
until [ "$name" = Smith ]     # Change  !=  to =.
do
  read name                   # Reads from $Filename, rather than stdin.
  echo $name
done <"$Filename"             # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^

# Same results as with "while" loop in previous example.


for name in `seq $line_count`  # Recall that "seq" prints sequence of numbers.
# while [ "$name" != Smith ]   --   more complicated than a "while" loop   --
do
  read name                    # Reads from $Filename, rather than stdin.
  echo $name
  if [ "$name" = Smith ]       # Need all this extra baggage here.
  then
    break
  fi  
done <"$Filename"              # Redirects stdin to file $Filename. 
#    ^^^^^^^^^^^^


for name in `seq $line_count`
do
  read name
  echo "$name"
  if [ "$name" = "$FinalName" ]
  then
    break
  fi  
done < "$Filename" > "$Savefile"     # Redirects stdin to file $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       and saves it to backup file.




crawling

encoding

sanitizing

indexing

language processing
  
  tokenizing
  
  bigram extracting
  
  trigram extracting

  freq distibuition

  similarity index extracting

  context extracting
  
  POS tagging

  grammar parsing

  indexing

regexp extracting

  names

  values

  addresses

  phones

  urls

  emails

  indexing


# get last line
tail -n 1 "$FILE"


# remove first line
tail -n +2 "$FILE"

# remove first line if is empty
The simplest thing in sed is:

sed '1{/^$/d}'
Note that this does not delete a line that contains all blanks, but only a line that contains nothing but a single newline. To get rid of blanks:

# other sed

sed '1{/^ *$/d}'
and to eliminate all whitespace:

sed '1{/^[[:space:]]*$/d}'


#mysql to csv
#-N tells it not to print column headers. -B is "batch mode", and uses tabs to separate fields.
mysql -N -B -e "select people, places from things"

#mysql to csv 2
SELECT order_id,product_name,qty
FROM orders
INTO OUTFILE '/tmp/orders.csv'
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n';

#daemon
update-rc.d $APP defaults
update-rc.d -f $APP remove

To run a daemon or any command as root before login, add it to /etc/rc.local or add a cron job with @reboot as its time field. You can also write a proper init script based on /etc/init.d/skeleton.
To run a command after login, add it to ~/.bash_profile (provided you re using bash). Contrary to ~/.bashrc, this file will be executed by login shells only.
To run a command after login of any new user, add an appropriate .bash_profile to /etc/skel and new users will get this file automatically on account creation.

# HEREDOC

cat << EOF > /tmp/yourfilehere
These contents will be written to the file.
        This line is not indented.
EOF

cat << 'EOF' > /tmp/yourfilehere
The variable $FOO will not be interpreted.
EOF

myvar='test'
echo foo${myvar}bar 
>footestbar

basename /usr/local/share/doc/foo/foo.txt
>foo.txt
basename /usr/home/drobbins
>drobbins

dirname /usr/local/share/doc/foo/foo.txt
>/usr/local/share/doc/foo
dirname /usr/home/drobbins/
>/usr/home


MYDIR=`dirname /usr/local/share/doc/foo/foo.txt`
echo $MYDIR
>/usr/local/share/doc/foo


MYDIR=$(dirname /usr/local/share/doc/foo/foo.txt)
echo $MYDIR
>/usr/local/share



if [ condition ]
then 
        action
elif [ condition2 ]
then
        action2
.
.
.
elif [ condition3 ]
then

else
        actionx
fi


echo number of arguments is $#


Common Bash comparisons
Operator	Meaning	Example
-z	Zero-length string	[ -z "$myvar" ]
-n	Non-zero-length string	[ -n "$myvar" ]
=	String equality	[ "abc" = "$myvar" ]
!=	String inequality	[ "abc" != "$myvar" ]
-eq	Numeric equality	[ 3 -eq "$myinteger" ]
-ne	Numeric inequality	[ 3 -ne "$myinteger" ]
-lt	Numeric strict less than	[ 3 -lt "$myinteger" ]
-le	Numeric less than or equals	[ 3 -le "$myinteger" ]
-gt	Numeric strict greater than	[ 3 -gt "$myinteger" ]
-ge	Numeric greater than or equals	[ 3 -ge "$myinteger" ]
-f	Exists and is regular file	[ -f "$myfile" ]
-d	Exists and is directory	[ -d "$mydir" ]
-nt	First file is newer than second one	[ "$myfile" -nt ~/.bashrc ]
-ot	First file is older than second one	[ "$myfile" -ot ~/.bashrc ]











case "$1" in
    a) cmd1 ;;
    b) cmd2 ;;
    c) cmd3 ;;
    *) cmd4 ;;
esac



NUMBERS="1 2 3"
for number in `echo $NUMBERS`
do
  echo $number 
done

for number in $NUMBERS
do
  echo -n $number
done

for number in 1 2 3
do
  echo -n $number
done



# file list loop

for file in *.tar.gz
do
    tar -xzf $file
done

# ls loop

for x in `ls -tr *.log`
do
   cat $x >> biglog
done



i="0"

while [ $i -lt 4 ]
	do
		xterm &
		i=$[$i+1]
	done



while true; do
	touch pic-`date +%s`.jpg
	sleep 300
done





# Calculate the average of a series of numbers.

SCORE="0"
AVERAGE="0"
SUM="0"
NUM="0"

while true; do

  echo -n "Enter your score [0-100%] ('q' for quit): "; read SCORE;

  if (("$SCORE" < "0"))  || (("$SCORE" > "100")); then
    echo "Be serious.  Common, try again: "
  elif [ "$SCORE" == "q" ]; then
    echo "Average rating: $AVERAGE%."
    break
  else
    SUM=$[$SUM + $SCORE]
    NUM=$[$NUM + 1]
    AVERAGE=$[$SUM / $NUM]
  fi

done

echo "Exiting."

#!/bin/bash

if [ -z "$var" ]; then echo "var is unset"; else echo "var is set to '$var'"; fi

if [ -z ${var+x} ]; then echo "var is unset"; else echo "var is set to '$var'"; fi



find . -type f -exec sed -i 's/foo/bar/g' {} +

find . -type f -print0 | xargs -0 sed -i 's///g'

sed -i.bak s/STRING_TO_REPLACE/STRING_TO_REPLACE_IT/g index.html

find . -type f -print0 | xargs -0 sed -i 's/resolveResource/resolvePackage/g'

find . -type f -print0 | xargs -0 sed -i 's///g'


